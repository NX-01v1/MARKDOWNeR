<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Markdownタブエディタ（強化版）</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2563eb">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" xintegrity="sha512-1ycn6IcaQQ40JuKakVxfBUaZtOoTYK7GuM/H3BlxvBftx86vJ+nsJLX+PFJdZXgLPNi4EDP6W3a6FmJ7/o7C/w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* CSS Variables for consistent heights */
        :root {
            --top-bar-height: 48px; /* Estimated height for top bar including padding */
            --tab-controls-height: 64px; /* Estimated height for tab controls bar */
        }

        /* Base styles for light mode */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            overflow: hidden;
            background-color: #f3f4f6; /* Light gray background */
            color: #1f2937; /* Dark text */
            transition: background-color 0.3s, color 0.3s;
        }

        /* Dark mode styles */
        body.dark-mode {
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
        }

        body.dark-mode #tab-list {
            background-color: #2d3748; /* Darker slate background */
            color: #a0aec0; /* Lighter gray text */
        }

        body.dark-mode #tab-list > header {
            border-bottom-color: #4a5568;
        }

        body.dark-mode .tab-item:hover {
            background-color: #4a5568;
            color: #e2e8f0;
        }

        body.dark-mode .tab-item.active {
            background-color: #4b5563; /* Same as light active, still good contrast */
            color: #ffffff;
        }

        body.dark-mode .delete-tab-btn {
            color: #cbd5e0;
        }

        body.dark-mode #resizer {
            background-color: #4a5568;
        }

        body.dark-mode #resizer:hover {
            background-color: #2d3748;
        }

        body.dark-mode #main {
            background-color: #2d3748; /* Dark background for main content */
        }

        body.dark-mode #top-bar {
            background-color: #2d3748; /* Same as shortcut panel */
            border-bottom-color: transparent;
            color: #e2e8f0;
        }
        body.dark-mode .top-bar-button {
            background-color: #2d3748;
            color: #e2e8f0;
            box-shadow: none; /* Removed shadow */
        }
        body.dark-mode .top-bar-button:hover {
            background-color: #2a3342;
        }


        /* Changed background for #tab-controls to be fully opaque */
        body.dark-mode #tab-controls {
            background-color: #2d3748; /* Solid dark background for controls */
            border-bottom-color: #4a5568;
        }

        body.dark-mode #tab-title-input {
            background-color: transparent;
            border-color: transparent;
            border-bottom-color: #e2e8f0;
            color: #e2e8f0;
        }

        body.dark-mode #tab-title-input:focus {
            border-color: transparent;
            border-bottom-color: #63b3ed;
            box-shadow: none;
        }

        body.dark-mode #markdown-shortcuts {
            background-color: #2a3342; /* Even darker for shortcut panel */
            color: #e2e8f0;
        }

        body.dark-mode .shortcut-button {
            background-color: #4a5568;
            color: #e2e8f0;
        }

        body.dark-mode .shortcut-button:hover {
            background-color: #64748b;
        }

        body.dark-mode .tab-shortcut-button {
            padding-top: 2rem;
            padding-bottom: 2rem;
            background-color: #6b7280;
            color: #1f2937;
        }
        body.dark-mode .tab-shortcut-button:hover {
            background-color: #5d6674;
        }

        /* Adjusted background for textarea and preview - NO TRANSPARENCY for text content */
        body.dark-mode textarea {
            background-color: #2d3748; /* Solid dark background */
            color: #e2e8f0;
            caret-color: #63b3ed;
        }

        body.dark-mode .markdown-preview {
            background-color: #2d3748; /* Solid dark background */
            color: #e2e8f0;
        }
        body.dark-mode .markdown-preview h1 { border-bottom-color: #4a5568; }
        body.dark-mode .markdown-preview code { background-color: #4a5568; }
        body.dark-mode .markdown-preview pre { background-color: #1a202c; }
        body.dark-mode .markdown-preview blockquote { border-left-color: #a0aec0; color: #cbd5e0; }
        body.dark-mode .markdown-preview th, body.dark-mode .markdown-preview td { border-color: #4a5568; }
        body.dark-mode .markdown-preview th { background-color: #4a5568; }
        body.dark-mode .markdown-preview a { color: #63b3ed; }

        /* Existing styles */
        body {
            background-color: #f3f4f6; /* Flat light gray background */
        }
        
        #tab-list {
            background-color: #1f2937; /* Solid darker slate background */
            color: #d1d5db;
            min-width: 4px;
            width: 250px;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            transition: width 0.2s ease-in-out;
            overflow: hidden;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2); /* Simpler shadow */
            padding-left: 1rem;
            padding-right: 1rem;
            border-radius: 0; /* No rounded corners */
        }
        #tab-list.minimized {
            width: 4px !important;
            min-width: 4px !important;
        }
        #tab-list.minimized > * {
            display: none;
        }
        #tab-list > header {
            padding-top: 1rem;
            padding-bottom: 1rem;
            font-weight: bold;
            font-size: 1.125rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-bottom: 1px solid #374151;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #tabs {
            flex: 1;
            overflow-y: auto;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        #tabs::-webkit-scrollbar {
            display: none;
        }
        .tab-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #374151;
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: background-color 0.2s, color 0.2s;
            position: relative;
            border-radius: 0; /* No rounded corners */
            margin-bottom: 0; /* No margin */
        }
        .tab-item:hover {
            background-color: #374151; /* Darker on hover */
            color: #e5e7eb;
        }
        .tab-item.active {
            background-color: #4b5563;
            font-weight: 600;
            color: #ffffff;
            box-shadow: none; /* No shadow */
        }
        .tab-item-text {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            padding-right: 0.5rem;
            padding-left: 8px;
        }
        .delete-tab-btn {
            background: none;
            border: none;
            color: #9ca3af;
            font-size: 1.25rem;
            cursor: pointer;
            padding: 0 0.25rem;
            line-height: 1;
            transition: color 0.2s;
        }
        .delete-tab-btn:hover {
            color: #ef4444;
        }
        #add-tab {
            background-color: #2563eb; /* Solid blue */
            color: #ffffff;
            border: none;
            cursor: pointer;
            padding-top: 0.75rem;
            padding-bottom: 0.75rem;
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 0; /* No rounded corners */
            margin-top: 1rem;
            margin-bottom: 1rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Simpler shadow */
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            width: 100%;
            box-sizing: border-box;
        }
        #add-tab:hover {
            background-color: #3b82f6; /* Lighter blue on hover */
            transform: translateY(0); /* No transform */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Simpler shadow */
        }
        #resizer {
            width: 8px;
            background-color: #6b7280;
            cursor: ew-resize;
            user-select: none;
            transition: background-color 0.2s;
            box-shadow: none; /* No shadow */
        }
        #resizer:hover {
            background-color: #4b5563;
            box-shadow: none; /* No shadow */
        }
        #main {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            user-select: text;
            background-color: #ffffff; /* Solid white */
            position: relative;
        }

        /* New Top Bar Styles */
        #top-bar {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.1rem 0.5rem;
            background-color: #f0f4f8; /* Solid light background */
            border-bottom: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); /* Simpler shadow */
            color: #374151;
            justify-content: space-between;
            height: var(--top-bar-height);
            flex-shrink: 0;
            z-index: 20;
            border-radius: 0; /* No rounded corners */
        }
        /* File dropdown specific styles */
        #file-dropdown {
            top: 100%;
            left: 0;
            min-width: 120px;
            background-color: #ffffff; /* Solid white */
            color: #1f2937;
            border: 1px solid #e5e7eb; /* Simple border */
            padding: 0.25rem 0;
            border-radius: 0.375rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Simpler shadow */
            z-index: 10;
        }
        #file-dropdown button {
            background-color: transparent;
            border: none;
            width: 100%;
            text-align: left;
            padding: 0.4rem 1rem;
            font-size: 0.875rem;
            font-weight: 400;
            cursor: pointer;
            transition: background-color 0.2s;
            outline: none;
            white-space: nowrap;
        }
        #file-dropdown button:hover {
            background-color: #f3f4f6;
        }

        body.dark-mode #file-dropdown {
            background-color: #2d3748;
            color: #e2e8f0;
            border: none;
        }
        body.dark-mode #file-dropdown button:hover {
            background-color: #4a5568;
        }

        .top-bar-button {
            background-color: #f0f4f8; /* Solid light background */
            color: #374151;
            border: none;
            padding: 0.2rem 0.6rem;
            border-radius: 0.375rem; /* Simpler rounded corners */
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 0;
            box-shadow: none; /* Removed shadow */
        }
        .top-bar-button:hover {
            background-color: #dfe6ed;
            transform: translateY(0); /* No transform */
            box-shadow: none; /* Removed shadow */
        }
        .top-bar-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #f3f4f6;
        }
        /* New style for settings button in top bar */
        #top-bar #settings-btn {
            background: none;
            border: none;
            color: #374151;
            padding: 0.2rem 0.6rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: color 0.2s, background-color 0.2s;
            box-shadow: none; /* Removed shadow */
        }
        #top-bar #settings-btn:hover {
            background-color: #dfe6ed;
            color: #1f2937;
            transform: none; /* No transform */
        }
        body.dark-mode #top-bar #settings-btn {
            color: #e2e8f0;
            background-color: #2d3748;
        }
        body.dark-mode #top-bar #settings-btn:hover {
            background-color: #2a3342;
            color: #ffffff;
        }
        #top-bar #settings-btn .fas {
            font-size: 1rem;
        }


        #tab-controls {
            height: var(--tab-controls-height);
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #d1d5db;
            display: flex;
            align-items: center;
            gap: 1rem;
            background-color: #f9fafb; /* Solid light background */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05); /* Simpler shadow */
            flex-shrink: 0;
        }
        /* Changed background for #tab-controls to be fully opaque */
        body.dark-mode #tab-controls {
            background-color: #2d3748; /* Solid dark background for controls */
            border-bottom-color: #4a5568;
        }
        #tab-title-input {
            flex: 1;
            font-size: 1.125rem;
            padding: 0.5rem 0.75rem;
            box-sizing: border-box;
            border: none;
            border-bottom: 1px solid #d1d5db;
            border-radius: 0;
            background-color: transparent;
            outline: none;
            transition: border-color 0.2s;
        }
        #tab-title-input:focus {
            border-color: #2563eb;
            box-shadow: none;
        }
        .toggle-btn {
            background-color: #6b7280; /* Solid gray */
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            font-size: 0.875rem;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Simpler shadow */
        }
        .toggle-btn:hover {
            background-color: #4b5563;
            transform: translateY(0); /* No transform */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Simpler shadow */
        }
        #editor-area-flex-container {
            flex: 1;
            display: flex;
            flex-direction: row;
            position: relative;
            overflow: hidden;
        }

        #markdown-shortcuts {
            width: 50px;
            background-color: #2d3748;
            color: #e2e8f0;
            padding: 0.25rem;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            overflow-y: scroll;
            box-shadow: 1px 0 3px rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
            padding-bottom: 100vh;
            border-radius: 0; /* No rounded corners */
        }
        /* Re-enable scrollbars for #markdown-shortcuts */
        #markdown-shortcuts::-webkit-scrollbar {
            display: block;
            width: 8px;
        }
        #markdown-shortcuts::-webkit-scrollbar-thumb {
            background-color: #888;
            border-radius: 4px;
        }
        #markdown-shortcuts::-webkit-scrollbar-track {
            background-color: #f1f1f1;
        }
        #markdown-shortcuts {
            -ms-overflow-style: auto;
            scrollbar-width: auto;
        }


        .shortcut-button {
            background-color: #4a5568;
            color: white;
            border: none;
            padding: 0.25rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            text-align: center;
            transition: background-color 0.2s, transform 0.1s;
            flex-shrink: 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .shortcut-button:hover {
            background-color: #64748b;
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .shortcut-button .fas {
            font-size: 1rem;
        }
        .tab-shortcut-button {
            padding-top: 2rem;
            padding-bottom: 2rem;
            background-color: #e0e0e0;
            color: #1f2937;
        }
        .tab-shortcut-button:hover {
            background-color: #cccccc;
        }

        #content-area {
            flex: 1;
            position: relative;
            display: flex;
            overflow: hidden;
            margin-left: 16px;
        }
        textarea, .markdown-preview {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            resize: none;
            font-family: monospace;
            font-size: 1rem;
            line-height: 24px;
            padding: 10px 16px 16px 16px;
            border: none;
            outline: none;
            box-sizing: border-box;
            background-color: #ffffff;
            color: #1f2937;
            z-index: 1;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            overflow-x: hidden;
            overflow-y: auto;
            caret-color: #2563eb;
            border-radius: 0.375rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        body.dark-mode textarea, body.dark-mode .markdown-preview {
            background-color: #2d3748;
            color: #e2e8f0;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }


        /* Markdown rendering styles for preview */
        .markdown-preview h1 {
            font-size: 2.25rem;
            font-weight: 700;
            margin-top: 1rem; /* Reduced from 1.5rem */
            margin-bottom: 0.75rem; /* Reduced from 1rem */
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0.5rem;
            line-height: normal;
        }
        .markdown-preview h2 {
            font-size: 1.875rem;
            font-weight: 600;
            margin-top: 0.75rem; /* Reduced from 1.25rem */
            margin-bottom: 0.5rem; /* Reduced from 0.75rem */
            line-height: normal;
        }
        .markdown-preview h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 0.5rem; /* Reduced from 1rem */
            margin-bottom: 0.25rem; /* Reduced from 0.5rem */
            line-height: normal;
        }
        .markdown-preview p {
            margin-bottom: 0.75rem; /* Reduced from 1rem */
            line-height: 1.5; /* Added line-height for better spacing */
        }
        .markdown-preview ul, .markdown-preview ol {
            list-style-position: outside;
            margin-bottom: 0.75rem; /* Reduced from 1rem */
            padding-left: 1.5rem;
        }
        .markdown-preview li {
            margin-bottom: 0.125rem; /* Further reduced for tighter spacing */
            line-height: 1.5; /* Added line-height for consistent spacing within lists */
        }
        .markdown-preview code { background-color: #e5e7eb; padding: 0.2rem 0.4rem; border-radius: 0.25rem; font-family: monospace; }
        .markdown-preview pre { background-color: #1f2937; color: #f9fafb; padding: 1rem; border-radius: 0.375rem; overflow-x: auto; margin-bottom: 1rem; }
        .markdown-preview pre code { background: none; padding: 0; color: inherit; }
        .markdown-preview blockquote { border-left: 4px solid #d1d5db; padding-left: 1rem; color: #6b7280; margin-bottom: 1rem; }
        .markdown-preview table { width: 100%; border-collapse: collapse; margin-bottom: 1rem; }
        .markdown-preview th, .markdown-preview td { border: 1px solid #d1d5db; padding: 0.5rem; text-align: left; }
        .markdown-preview th { background-color: #f3f4f6; font-weight: 600; }
        .markdown-preview a { color: #2563eb; text-decoration: underline; }
        .markdown-preview img { max-width: 100%; height: auto; display: block; margin: 1rem 0; border-radius: 0.375rem; }

        /* Settings Modal Styles */
        .settings-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        .settings-modal-overlay.open {
            opacity: 1;
            visibility: visible;
        }

        .settings-modal-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            transform: translateY(-20px);
            opacity: 0;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            position: relative;
            box-sizing: border-box;
        }
        body.dark-mode .settings-modal-content {
            background-color: #2d3748;
            color: #e2e8f0;
        }
        body.dark-mode .settings-modal-header {
            border-bottom-color: #4a5568;
        }
        body.dark-mode .settings-modal-header h2 {
            color: #e2e8f0;
        }
        body.dark-mode .settings-modal-close-btn {
            color: #a0aec0;
        }
        body.dark-mode .settings-modal-close-btn:hover {
            color: #e2e8f0;
        }
        body.dark-mode .settings-modal-body input[type="text"],
        body.dark-mode .settings-modal-body input[type="number"] {
            background-color: #4a5568;
            border-color: #4a5568;
            color: #e2e8f0;
        }
        body.dark-mode .settings-modal-body input[type="text"]:focus,
        body.dark-mode .settings-modal-body input[type="number"]:focus {
            border-color: #63b3ed;
            box-shadow: 0 0 0 2px rgba(99, 179, 237, 0.2);
        }
        body.dark-mode .settings-modal-body .add-shortcut-btn,
        body.dark-mode .settings-modal-body .visibility-toggle-btn {
            background-color: #2563eb;
            color: #ffffff;
        }
        body.dark-mode .settings-modal-body .add-shortcut-btn:hover,
        body.dark-mode .settings-modal-body .visibility-toggle-btn:hover {
            background-color: #3b82f6;
        }
        body.dark-mode .settings-modal-body .shortcut-list-item {
            background-color: #1f2937;
            border-color: #4a5568;
        }
        body.dark-mode .settings-modal-body .shortcut-list-item.dragging {
            opacity: 0.5;
        }
        body.dark-mode .settings-modal-body .shortcut-list-item.drag-over {
            border-top: 2px solid #63b3ed;
        }
        body.dark-mode .settings-modal-body .shortcut-list-item.hidden-shortcut {
            opacity: 0.6;
            color: #a0aec0;
            background-color: #2a3342;
        }


        .settings-modal-overlay.open .settings-modal-content {
            transform: translateY(-20px); /* Keep the same transform for consistent animation */
            opacity: 1;
            transform: translateY(0); /* Corrected transform */
        }


        .settings-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 1rem;
            margin-bottom: 1.5rem;
        }

        .settings-modal-header h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1f2937;
        }

        .settings-modal-close-btn {
            background: none;
            border: none;
            font-size: 2rem;
            color: #6b7280;
            cursor: pointer;
            transition: color 0.2s;
        }

        .settings-modal-close-btn:hover {
            color: #1f2937;
        }

        .settings-modal-section {
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid #e5e7eb;
        }
        body.dark-mode .settings-modal-section {
            border-bottom-color: #4a5568;
        }
        .settings-modal-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .settings-modal-section h3 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #1f2937;
        }
        body.dark-mode .settings-modal-section h3 {
            color: #e2e8f0;
        }

        .theme-options label {
            display: inline-flex;
            align-items: center;
            margin-right: 1.5rem;
            cursor: pointer;
        }
        .theme-options input[type="radio"] {
            margin-right: 0.5rem;
        }

        .shortcut-list-item {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            margin-bottom: 0.5rem;
            cursor: default;
            transition: background-color 0.2s, box-shadow 0.2s, opacity 0.3s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }
        body.dark-mode .shortcut-list-item {
            background-color: #1f2937;
            border-color: #4a5568;
        }
        .shortcut-list-item.dragging {
            opacity: 0.5;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .shortcut-list-item.drag-over {
            border-top: 2px solid #2563eb;
        }
        .shortcut-list-item.hidden-shortcut {
            opacity: 0.6;
            color: #6b7280;
            background-color: #e5e7eb;
        }
        .shortcut-list-item span.shortcut-display-text {
            font-family: monospace;
            font-size: 0.9rem;
            flex-grow: 1;
            margin-right: 1rem;
        }
        .visibility-toggle-btn {
            background-color: #2563eb;
            color: white;
            border: none;
            padding: 0.25rem 0.6rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background-color 0.2s, transform 0.1s;
            flex-shrink: 0;
        }
        .visibility-toggle-btn:hover {
            background-color: #3b82f6;
            transform: translateY(0);
        }
        .visibility-toggle-btn.hide-btn {
            background-color: #f59e0b;
        }
        .visibility-toggle-btn.hide-btn:hover {
            background-color: #d97706;
        }
        .visibility-toggle-btn.show-btn {
            background-color: #10b981;
        }
        .visibility-toggle-btn.show-btn:hover {
            background-color: #059669;
        }


        .drag-handle {
            font-size: 1.2rem;
            color: #9ca3af;
            margin-right: 0.75rem;
            cursor: grab;
            padding: 0 0.25rem;
            flex-shrink: 0;
        }
        body.dark-mode .drag-handle {
            color: #cbd5e0;
        }
        .drag-handle:active {
            cursor: grabbing;
        }

        .add-shortcut-form {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px dashed #d1d5db;
        }
        body.dark-mode .add-shortcut-form {
            border-top-color: #4a5568;
        }

        .add-shortcut-form input {
            padding: 0.5rem 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .add-shortcut-form input:focus {
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
        }
        .add-shortcut-btn {
            background-color: #2563eb;
            color: white;
            border: none;
            padding: 0.75rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .add-shortcut-btn:hover {
            background-color: #3b82f6;
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        .input-group label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #4b5563;
        }
        body.dark-mode .input-group label {
            color: #a0aec0;
        }

        .reset-button {
            background-color: #d97706;
            color: white;
            border: none;
            padding: 0.75rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s, transform 0.1s;
            margin-top: 1rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .reset-button:hover {
            background-color: #b45309;
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body>

<div id="tab-list" class="shadow-lg px-4">
    <header>
        <span>タブ</span>
    </header>
    <div id="tabs" class="flex-1 overflow-y: auto;"></div>
    <button id="add-tab" class="rounded-md">+</button>
</div>
<div id="resizer" title="タブ管理の幅をドラッグ/クリックで折りたたみ"></div>

<div id="main" class="flex-1 flex flex-col h-screen relative">
    <div id="top-bar" class="flex items-center gap-2 p-2 border-b border-gray-300 bg-blue-50">
        <div class="relative">
            <button id="file-btn" class="top-bar-button">ファイル</button>
            <div id="file-dropdown" class="absolute hidden rounded-md shadow-lg py-1 z-10">
                <button id="import-btn" class="block w-full text-left px-4 py-2">インポート</button>
                <button id="export-btn" class="block w-full text-left px-4 py-2">エクスポート</button>
                <button id="save-all-tabs-btn" class="block w-full text-left px-4 py-2">すべてを1ファイルで保存</button>
                <button id="icloud-link-btn" class="block w-full text-left px-4 py-2">iCloud</button>
            </div>
        </div>
        <div class="flex-grow"></div>
        <button id="settings-btn" class="top-bar-button" title="設定">
            <i class="fas fa-cog text-lg"></i>
        </button>
    </div>

    <div id="tab-controls">
        <input type="text" id="tab-title-input" placeholder="タブ名" class="flex-1 text-lg p-2 focus:outline-none"/>
        <button id="toggle-preview-btn" class="toggle-btn bg-gray-500 hover:bg-gray-600">プレビューに切り替え</button>
    </div>

    <div id="editor-area-flex-container" class="flex-1 flex flex-row relative">
        <div id="markdown-shortcuts">
        </div>
        <div id="content-area" class="flex-1 relative overflow-hidden">
        </div>
    </div>
</div>

<div id="settings-modal-overlay" class="settings-modal-overlay">
    <div class="settings-modal-content">
        <div class="settings-modal-header">
            <h2>設定</h2>
            <button id="settings-modal-close-btn" class="settings-modal-close-btn">&times;</button>
        </div>
        <div class="settings-modal-body">
            <div class="settings-modal-section">
                <h3>テーマ</h3>
                <div class="theme-options">
                    <label>
                        <input type="radio" name="theme" value="light" id="theme-light"> ライトモード
                    </label>
                    <label>
                        <input type="radio" name="theme" value="dark" id="theme-dark"> ダークモード
                    </label>
                </div>
            </div>

            <div class="settings-modal-section">
                <h3>ショートカットボタンの管理</h3>
                <div id="current-shortcuts-list" class="flex flex-col gap-2">
                </div>
                <div class="add-shortcut-form">
                    <h4>新しいショートカットを追加</h4>
                    <div class="input-group">
                        <label for="new-shortcut-text">表示テキスト (例: H1, Bold)</label>
                        <input type="text" id="new-shortcut-text" placeholder="ボタンの表示名" />
                    </div>
                    <div class="input-group">
                        <label for="new-shortcut-markdown">Markdown構文 (例: # , **, []())</label>
                        <input type="text" id="new-shortcut-markdown" placeholder="挿入するMarkdown" />
                    </div>
                    <div class="input-group">
                        <label for="new-shortcut-offset">カーソルオフセット (挿入後カーソルを移動する位置)</label>
                        <input type="number" id="new-shortcut-offset" value="0" min="0" />
                    </div>
                    <button id="add-new-shortcut-btn" class="add-shortcut-btn">ショートカットを追加</button>
                </div>
                <button id="reset-shortcuts-btn" class="reset-button">ショートカットをリセット</button>
            </div>

            <div class="settings-modal-section">
                <h3>iCloud設定</h3>
                <div class="input-group">
                    <label for="icloud-url-input">iCloudウェブサイトURL</label>
                    <input type="text" id="icloud-url-input" placeholder="例: https://www.icloud.com/" />
                </div>
                <button id="save-icloud-url-btn" class="add-shortcut-btn mt-4">URLを保存</button>
            </div>

        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
    const tabList = document.getElementById('tab-list');
    const tabsDiv = document.getElementById('tabs');
    const addTabBtn = document.getElementById('add-tab');
    const resizer = document.getElementById('resizer');
    const tabTitleInput = document.getElementById('tab-title-input');
    const togglePreviewBtn = document.getElementById('toggle-preview-btn');
    const contentArea = document.getElementById('content-area');
    const markdownShortcuts = document.getElementById('markdown-shortcuts');
    const settingsBtn = document.getElementById('settings-btn');
    const settingsModalOverlay = document.getElementById('settings-modal-overlay');
    const settingsModalCloseBtn = document.getElementById('settings-modal-close-btn');

    // Top Bar Buttons
    const fileBtn = document.getElementById('file-btn');
    const fileDropdown = document.getElementById('file-dropdown');
    const importBtn = document = document.getElementById('import-btn');
    const exportBtn = document.getElementById('export-btn');
    const saveAllTabsBtn = document.getElementById('save-all-tabs-btn'); // Re-added button reference
    const icloudLinkBtn = document.getElementById('icloud-link-btn');

    // Settings elements
    const themeLightRadio = document.getElementById('theme-light');
    const themeDarkRadio = document.getElementById('theme-dark');
    const currentShortcutsList = document.getElementById('current-shortcuts-list');
    const newShortcutText = document.getElementById('new-shortcut-text');
    const newShortcutMarkdown = document.getElementById('new-shortcut-markdown');
    const newShortcutOffset = document.getElementById('new-shortcut-offset');
    const addNewShortcutBtn = document.getElementById('add-new-shortcut-btn');
    const resetShortcutsBtn = document.getElementById('reset-shortcuts-btn');
    const icloudUrlInput = document.getElementById('icloud-url-input');
    const saveIcloudUrlBtn = document.getElementById('save-icloud-url-btn');

    let tabs = [];
    let currentTabId = null;
    let isTabListOpen = true;
    let draggedShortcutId = null;
    let icloudUrl = 'https://www.icloud.com/'; // Default iCloud URL

    // New delimiter for combined tab files (less likely to conflict with Markdown)
    const TAB_FILE_DELIMITER = '=== TAB_SEPARATOR ===';

    // Default initial shortcuts if no saved settings are found
    const defaultInitialShortcuts = [
        { id: 'h1', text: 'H1', markdown: '# ', offset: 2, title: '見出し1', hidden: false },
        { id: 'h2', text: 'H2', markdown: '## ', offset: 3, title: '見出し2', hidden: false },
        { id: 'h3', text: 'H3', markdown: '### ', offset: 4, title: '見出し3', hidden: false },
        { id: 'bold', text: '<i class="fas fa-bold"></i>', markdown: '****', offset: 2, title: '太字', hidden: false },
        { id: 'italic', text: '<i class="fas fa-italic"></i>', markdown: '**', offset: 1, title: '斜体', hidden: false },
        { id: 'link', text: '<i class="fas fa-link"></i>', markdown: '[]()', offset: 1, title: 'リンク', hidden: false },
        { id: 'ul', text: '<i class="fas fa-list-ul"></i>', markdown: '- ', list: true, title: '順序なしリスト', hidden: false },
        { id: 'ol', text: '<i class="fas fa-list-ol"></i>', markdown: '1. ', list: true, title: '順序ありリスト', hidden: false },
        { id: 'codeblock', text: '<i class="fas fa-code"></i>', markdown: '```\n\n```', offset: 4, title: 'コードブロック', hidden: false },
        { id: 'quote', text: '<i class="fas fa-quote-left"></i>', markdown: '> ', title: '引用', hidden: false }
    ];

    // The fixed Tab shortcut, always at the very bottom, not user-managed
    const fixedTabShortcut = { id: 'tab', text: 'Tab', markdown: '    ', offset: 4, fixed: true, className: 'tab-shortcut-button', title: 'タブ' };

    // This array will hold all user-managed shortcuts (default ones and custom-added ones)
    let userManagedShortcuts = []; 

    // Set Marked.js options
    marked.setOptions({
        breaks: true, // Render newlines as <br>
        gfm: true // Enable GitHub Flavored Markdown
    });

    /**
     * Creates a new tab object.
     * @param {string} name - The name of the tab.
     * @param {string} content - The content of the tab.
     * @returns {object} The new tab object.
     */
    function createTab(name = '無題', content = '') {
        return {
            id: 'tab_' + Date.now() + Math.random().toString(36).slice(2),
            name,
            content,
            isPreview: false // Whether it's in preview mode
        };
    }

    /**
     * Renders the tab list.
     */
    function renderTabList() {
        tabsDiv.innerHTML = '';
        tabs.forEach(tab => {
            const div = document.createElement('div');
            div.className = `tab-item ${tab.id === currentTabId ? 'active' : ''} rounded-md`;

            const tabTextSpan = document.createElement('span');
            tabTextSpan.className = 'tab-item-text';
            tabTextSpan.textContent = tab.name || '無題';
            tabTextSpan.title = tab.name || '無題';
            div.appendChild(tabTextSpan);

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-tab-btn';
            deleteBtn.innerHTML = '&times;'; // HTML entity for multiplication sign (looks like 'x')
            deleteBtn.title = 'タブを削除';
            deleteBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent tab switch when deleting
                deleteTab(tab.id); // Call deleteTab directly
            };
            div.appendChild(deleteBtn);

            div.onclick = () => {
                if (tab.id === currentTabId) return;
                switchTab(tab.id); // Call the main switch function
            };
            tabsDiv.appendChild(div);
        });
        saveSettings();
    }

    /**
     * Renders the editor and preview in the main content area.
     */
    function renderContent() {
        contentArea.innerHTML = '';
        tabs.forEach(tab => {
            const textarea = document.createElement('textarea');
            textarea.value = tab.content;
            textarea.spellcheck = false;
            textarea.autocapitalize = 'off';
            textarea.autocomplete = 'off';
            textarea.autocorrect = 'off';
            textarea.id = `textarea-${tab.id}`; // Give unique ID to textarea
            contentArea.appendChild(textarea);

            const preview = document.createElement('div');
            preview.id = `preview-${tab.id}`; // Give unique ID to preview
            preview.classList.add('markdown-preview'); // Add the new class
            // Convert Markdown to HTML using Marked.js
            preview.innerHTML = marked.parse(tab.content);
            contentArea.appendChild(preview);

            // Add references to DOM elements to the tab object
            tab._textarea = textarea;
            tab._preview = preview;

            // This function handles both content update and preview rendering.
            tab._updateContentAndPreview = () => {
                tab.content = textarea.value;
                preview.innerHTML = marked.parse(textarea.value);
                saveSettings(); // Save whenever content changes
            };

            // Event listeners for textarea using the new functions
            textarea.addEventListener('input', () => {
                tab._updateContentAndPreview();
            });

            // The textarea's display style will be handled by switchTab
            if (tab.id === currentTabId) {
                if (tab.isPreview) {
                    preview.style.display = 'block';
                    textarea.style.display = 'none';
                } else {
                    textarea.style.display = 'block';
                    preview.style.display = 'none';
                }
            } else {
                textarea.style.display = 'none';
                preview.style.display = 'none';
            }
        });
    }

    /**
     * Get the current active textarea element.
     * @returns {HTMLTextAreaElement|null} Current textarea element, or null.
     */
    function getCurrentTextarea() {
        const currentTab = tabs.find(t => t.id === currentTabId);
        return currentTab ? currentTab._textarea : null;
    }

    /**
     * Inserts text at the cursor position and adjusts the cursor position.
     * @param {HTMLTextAreaElement} textarea - The target textarea element.
     * @param {string} textToInsert - The text to insert.
     * @param {number} cursorOffset - The offset for the cursor position after insertion, relative to the start of the inserted text.
     */
    function insertAtCursor(textarea, textToInsert, cursorOffset = 0) {
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const value = textarea.value;

        textarea.value = value.substring(0, start) + textToInsert + value.substring(end);

        // Get the current tab object to update its properties
        const currentTab = tabs.find(t => t.id === currentTabId);
        if (currentTab) {
            currentTab._updateContentAndPreview(); // Call content and preview update explicitly
        }

        // Adjust cursor position
        const newCursorPos = start + cursorOffset;
        textarea.selectionStart = newCursorPos;
        textarea.selectionEnd = newCursorPos;

        textarea.focus(); // Keep focus on the textarea
    }

    /**
     * Inserts a list item. Ensures a blank line before the list and places the cursor correctly.
     * @param {HTMLTextAreaElement} textarea - The target textarea element.
     * @param {string} listItemPrefix - The prefix for the list item (e.g., '- ', '1. ').
     */
    function insertListItem(textarea, listItemPrefix) {
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const value = textarea.value;

        // Get the content before the cursor
        const beforeSelection = value.substring(0, start);
        
        let textToPrepend = ''; // Text to add before the list item itself
        let cursorOffsetAdjustment = 0;

        // Ensure there's a blank line (two newlines) before the list block
        // Find how many newlines are currently at the end of the content before cursor
        const newlinesAtEndMatch = beforeSelection.match(/\n+$/);
        const numNewlinesAtEnd = newlinesAtEndMatch ? newlinesAtEndMatch[0].length : 0;

        if (numNewlinesAtEnd < 2) {
            textToPrepend += '\n'.repeat(2 - numNewlinesAtEnd);
            cursorOffsetAdjustment = textToPrepend.length;
        }

        // Check if the current line (where cursor is) has content.
        // If so, the list item itself should start on a new line after the blank line.
        const lastNewlineIndex = beforeSelection.lastIndexOf('\n');
        const currentLineContent = beforeSelection.substring(lastNewlineIndex + 1);
        
        if (currentLineContent.trim().length > 0) {
            textToPrepend += '\n'; // Add another newline to push the list item to a new line
            cursorOffsetAdjustment++; // Adjust cursor offset for this extra newline
        }

        const textToInsert = textToPrepend + listItemPrefix;
        const newCursorPos = start + cursorOffsetAdjustment + listItemPrefix.length;

        // Update textarea value
        textarea.value = value.substring(0, start) + textToInsert + value.substring(end);

        // Update tab content and preview immediately
        const currentTab = tabs.find(t => t.id === currentTabId);
        if (currentTab) {
            currentTab._updateContentAndPreview();
        }

        // Set cursor position
        textarea.selectionStart = newCursorPos;
        textarea.selectionEnd = newCursorPos;
        textarea.focus();
    }


    /**
     * Switches to preview mode.
     * @param {object} tab - The target tab object.
     */
    function switchToPreview(tab) {
        if (!tab || !tab._textarea || !tab._preview) return;
        tab.isPreview = true;
        tab._textarea.style.display = 'none';
        tab._preview.style.display = 'block';
        togglePreviewBtn.textContent = 'エディタに切り替え';
        saveSettings();
    }

    /**
     * Switches to edit mode.
     * @param {object} tab - The target tab object.
     */
    function switchToEdit(tab) {
        if (!tab || !tab._textarea || !tab._preview) return;
        tab.isPreview = false;
        tab._textarea.style.display = 'block';
        tab._textarea.value = tab.content; /* Ensure textarea content is up-to-date */
        tab._preview.style.display = 'none';
        togglePreviewBtn.textContent = 'プレビューに切り替え';
        
        // Use setTimeout to ensure focus and selection range are applied after the display change has fully rendered
        setTimeout(() => {
            const len = tab._textarea.value.length;
            tab._textarea.setSelectionRange(len, len); // Places cursor at the end without selection
            tab._textarea.focus(); // Focus on the textarea
        }, 0); // Execute immediately after current script block finishes

        saveSettings();
    }

    /**
     * Switches tabs.
     * @param {string} id - The ID of the tab to switch to.
     */
    function switchTab(id) {
        if (id === currentTabId) return;

        // Hide the current active tab's textarea and preview
        if (currentTabId) {
            const oldTab = tabs.find(t => t.id === currentTabId);
            if (oldTab && oldTab._textarea && oldTab._preview) {
                oldTab._textarea.style.display = 'none';
                oldTab._preview.style.display = 'none';
            }
        }

        currentTabId = id;
        const newTab = tabs.find(t => t.id === currentTabId);
        if (!newTab) return;

        // Display the new tab's textarea or preview based on its mode
        if (newTab.isPreview) {
            switchToPreview(newTab);
        } else {
            switchToEdit(newTab);
        }

        tabTitleInput.value = newTab.name;
        renderTabList(); // Update active state of tab list
        saveSettings();
    }

    /**
     * Deletes a tab without confirmation.
     * @param {string} id - The ID of the tab to delete.
     */
    function deleteTab(id) {
        // Directly call performDeleteTab without a modal
        performDeleteTab(id);
    }

    /**
     * Performs the actual tab deletion after confirmation.
     * @param {string} id - The ID of the tab to delete.
     */
    function performDeleteTab(id) {
        const index = tabs.findIndex(tab => tab.id === id);
        if (index === -1) return;

        // Delete DOM elements for the tab
        const tabToDelete = tabs[index];
        if (tabToDelete._textarea && tabToDelete._textarea.parentNode) {
            tabToDelete._textarea.parentNode.removeChild(tabToDelete._textarea);
        }
        if (tabToDelete._preview && tabToDelete._preview.parentNode) {
            tabToDelete._preview.parentNode.removeChild(tabToDelete._preview);
        }

        tabs.splice(index, 1); // Remove tab from array

        if (tabs.length === 0) {
            // If all tabs are deleted, create a new tab
            const newTab = createTab();
            tabs.push(newTab);
            currentTabId = newTab.id;
            renderContent(); // Render content for the new tab
            switchTab(newTab.id); 
        } else {
            // If the deleted tab was the current one, switch to the first available tab
            if (currentTabId === id) {
                switchTab(tabs[0].id); // Fallback to first tab
            } else {
                renderTabList(); // Only re-render tab list if current tab is not deleted
                saveSettings(); // Ensure settings are saved even if tab not switched
            }
        }
        saveSettings();
    }


    /**
     * Renders the shortcut buttons in the markdown shortcuts panel.
     */
    function renderShortcutButtons() {
        markdownShortcuts.innerHTML = ''; // Clear existing buttons
        // Iterate through userManagedShortcuts directly, but filter out hidden ones
        userManagedShortcuts.filter(s => !s.hidden).forEach(shortcut => { // Filter here
            const button = document.createElement('button');
            button.className = `shortcut-button ${shortcut.className || ''}`;
            button.dataset.markdown = shortcut.markdown;
            if (shortcut.offset !== undefined) button.dataset.offset = shortcut.offset;
            if (shortcut.list) button.dataset.list = 'true';
            button.title = shortcut.title || shortcut.text.replace(/<[^>]*>?/gm, ''); // Use title if available, otherwise strip HTML from text
            button.innerHTML = shortcut.text;
            markdownShortcuts.appendChild(button);
        });
        // Always add the fixed Tab shortcut at the very bottom
        const tabButton = document.createElement('button');
        tabButton.className = `shortcut-button ${fixedTabShortcut.className}`;
        tabButton.dataset.markdown = fixedTabShortcut.markdown;
        tabButton.dataset.offset = fixedTabShortcut.offset;
        tabButton.title = fixedTabShortcut.title;
        tabButton.textContent = fixedTabShortcut.text;
        markdownShortcuts.appendChild(tabButton);
    }

    /**
     * Renders the current shortcuts list within the settings modal.
     */
    function renderSettingsShortcutsList() {
        currentShortcutsList.innerHTML = ''; // Clear existing list items

        userManagedShortcuts.forEach(shortcut => {
            const listItem = document.createElement('div');
            listItem.className = `shortcut-list-item ${shortcut.hidden ? 'hidden-shortcut' : ''}`; // Add class for hidden items
            
            // Add drag handle for all user-managed shortcuts
            const dragHandle = document.createElement('span');
            dragHandle.className = 'drag-handle';
            dragHandle.innerHTML = '&#x22ee;'; // Vertical ellipsis character
            dragHandle.title = 'ドラッグして並べ替え';
            listItem.appendChild(dragHandle);
            
            // Text content
            const textSpan = document.createElement('span');
            textSpan.className = 'shortcut-display-text';
            textSpan.innerHTML = `${shortcut.text.replace(/<[^>]*>?/gm, '')} - \`${shortcut.markdown.replace(/\n/g, '\\n')}\``;
            listItem.appendChild(textSpan);

            listItem.dataset.shortcutId = shortcut.id;
            listItem.draggable = true; // All user-managed shortcuts are draggable

            const visibilityToggleBtn = document.createElement('button'); // Renamed from deleteBtn
            visibilityToggleBtn.className = `visibility-toggle-btn ${shortcut.hidden ? 'show-btn' : 'hide-btn'}`;
            visibilityToggleBtn.textContent = shortcut.hidden ? '表示' : '非表示';
            visibilityToggleBtn.onclick = () => {
                toggleShortcutVisibility(shortcut.id);
            };
            listItem.appendChild(visibilityToggleBtn);
            currentShortcutsList.appendChild(listItem);
        });
    }

    /**
     * Toggles the visibility of a shortcut.
     * @param {string} idToToggle - The ID of the shortcut to toggle.
     */
    function toggleShortcutVisibility(idToToggle) {
        const shortcut = userManagedShortcuts.find(s => s.id === idToToggle);
        if (shortcut) {
            shortcut.hidden = !shortcut.hidden; // Toggle hidden status
            saveSettings();
            renderShortcutButtons(); // Update main panel
            renderSettingsShortcutsList(); // Update settings list
        }
    }

    /**
     * Saves application settings (tabs, theme, shortcuts, iCloud URL) to local storage.
     */
    function saveSettings() {
        try {
            const dataToSave = tabs.map(tab => ({
                id: tab.id,
                name: tab.name,
                content: tab.content,
                isPreview: tab.isPreview
            }));
            localStorage.setItem('markdownEditorTabs', JSON.stringify(dataToSave));
            localStorage.setItem('markdownEditorCurrentTabId', currentTabId);

            const settings = {
                theme: document.querySelector('input[name="theme"]:checked')?.value || 'light',
                shortcuts: userManagedShortcuts, // Save all user-managed shortcuts
                icloudUrl: icloudUrl // Save iCloud URL
            };
            localStorage.setItem('markdownEditorSettings', JSON.stringify(settings));

        }
        catch (e) {
            console.error("Failed to save to local storage:", e);
        }
    }

    /**
     * Loads application settings (tabs, theme, shortcuts, iCloud URL) from local storage.
     * @returns {object} Loaded settings.
     */
    function loadSettings() {
        try {
            const savedTabs = localStorage.getItem('markdownEditorTabs');
            const savedCurrentTabId = localStorage.getItem('markdownEditorCurrentTabId');
            if (savedTabs) {
                tabs = JSON.parse(savedTabs);
                if (tabs.length > 0) {
                    currentTabId = savedCurrentTabId && tabs.some(t => t.id === savedCurrentTabId) ? savedCurrentTabId : tabs[0].id;
                }
            }

            const savedSettings = localStorage.getItem('markdownEditorSettings');
            let settings = { theme: 'light', shortcuts: [], icloudUrl: 'https://www.icloud.com/' }; // Default iCloud URL added
            if (savedSettings) {
                const parsedSettings = JSON.parse(savedSettings);
                settings = { ...settings, ...parsedSettings }; // Merge with defaults
            }

            // If no shortcuts saved or if they are outdated, use defaultInitialShortcuts,
            // otherwise use saved shortcuts. Ensure all defaultInitialShortcuts are present and not hidden initially.
            if (settings.shortcuts && settings.shortcuts.length > 0) {
                // Merge saved shortcuts with defaultInitialShortcuts to ensure all default IDs are present
                const mergedShortcutsMap = new Map(defaultInitialShortcuts.map(s => [s.id, s]));
                settings.shortcuts.forEach(s => {
                    // Overwrite default properties with saved ones, maintaining order
                    mergedShortcutsMap.set(s.id, { ...mergedShortcutsMap.get(s.id), ...s });
                });
                userManagedShortcuts = Array.from(mergedShortcutsMap.values());
                // Reorder userManagedShortcuts based on the saved order
                const savedOrderIds = settings.shortcuts.map(s => s.id);
                userManagedShortcuts.sort((a, b) => {
                    const indexA = savedOrderIds.indexOf(a.id);
                    const indexB = savedOrderIds.indexOf(b.id);
                    if (indexA === -1 && indexB === -1) return 0; // Both are new defaults
                    if (indexB === -1) return -1; // b is new, a is saved, so a comes first
                    if (indexA === -1) return 1; // a is new, b is saved, so b comes first
                    return indexA - indexB;
                });

            } else {
                userManagedShortcuts = [...defaultInitialShortcuts]; // Use initial defaults
            }
            
            icloudUrl = settings.icloudUrl; // Set the global icloudUrl from loaded settings

            return settings;
        }
        catch (e) {
            console.error("Failed to load from local storage:", e);
            localStorage.removeItem('markdownEditorTabs');
            localStorage.removeItem('markdownEditorCurrentTabId');
            localStorage.removeItem('markdownEditorSettings');
            // Reset to default if load fails
            tabs = [];
            userManagedShortcuts = [...defaultInitialShortcuts]; // Reset to initial defaults
            icloudUrl = 'https://www.icloud.com/'; // Reset iCloud URL to default
            return { theme: 'light', shortcuts: [], icloudUrl: 'https://www.icloud.com/' };
        }
    }

    /**
     * Applies the selected theme to the body element.
     * @param {string} theme - 'light' or 'dark'.
     */
    function applyTheme(theme) {
        if (theme === 'dark') {
            document.body.classList.add('dark-mode');
            themeDarkRadio.checked = true;
        } else {
            document.body.classList.remove('dark-mode');
            themeLightRadio.checked = true;
        }
    }

    /**
     * Displays a custom modal message.
     * @param {string} title - The title of the modal.
     * @param {string} message - The message content.
     * @param {string} modalIdPrefix - A prefix for the modal ID to ensure uniqueness.
     */
    function showModalMessage(title, message, modalIdPrefix) {
        let modal = document.getElementById(modalIdPrefix);
        if (!modal) {
            modal = document.createElement('div');
            modal.id = modalIdPrefix;
            modal.className = 'settings-modal-overlay';
            modal.innerHTML = `
                <div class="settings-modal-content">
                    <div class="settings-modal-header">
                        <h2>${title}</h2>
                        <button class="settings-modal-close-btn">&times;</button>
                    </div>
                    <div class="settings-modal-body">
                        <p>${message}</p>
                        <div class="flex justify-end gap-4 mt-6">
                            <button class="toggle-btn">閉じる</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            modal.querySelector('.toggle-btn').onclick = () => modal.classList.remove('open');
            modal.querySelector('.settings-modal-close-btn').onclick = () => modal.classList.remove('open');
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.classList.remove('open');
            });
        } else {
            modal.querySelector('.settings-modal-header h2').textContent = title;
            modal.querySelector('.settings-modal-body p:first-of-type').textContent = message;
        }
        modal.classList.add('open');
    }

    /**
     * Sanitizes a string to be used as a filename.
     * @param {string} name - The original string.
     * @returns {string} The sanitized filename.
     */
    function sanitizeFilename(name) {
        // Replace characters that are generally unsafe in filenames with an underscore
        // Also remove leading/trailing spaces and dots
        return name.replace(/[<>:"/\\|?*\x00-\x1F]/g, '_') // Replace invalid characters with underscore
                   .replace(/^\.+/, '')                  // Remove leading dots
                   .replace(/\.+$/, '')                  // Remove trailing dots
                   .trim()                               // Trim whitespace
                   .substring(0, 250);                   // Limit length to avoid issues
    }

    // Event Listeners
    tabTitleInput.addEventListener('input', () => {
        if (!currentTabId) return;
        const tab = tabs.find(t => t.id === currentTabId);
        if (!tab) return;
        tab.name = tabTitleInput.value || '無題';
        renderTabList(); // Update tab list display
        saveSettings();
    });

    addTabBtn.addEventListener('click', () => {
        const newTab = createTab(); // Create tab with default name
        tabs.push(newTab);
        renderContent(); // Render content for the new tab
        switchTab(newTab.id); // Switch to the new tab

        // Focus on the input field after tab switch
        setTimeout(() => {
            tabTitleInput.focus();
            tabTitleInput.select(); // Select all text for quick editing
        }, 0); // Small delay until DOM update is complete
    });

    togglePreviewBtn.addEventListener('click', () => {
        const currentTab = tabs.find(t => t.id === currentTabId);
        if (currentTab) {
            // FIX: Corrected logic for toggle preview button
            if (currentTab.isPreview) { // If currently in preview mode
                switchToEdit(currentTab); // Switch to edit mode
            } else { // If currently in edit mode
                switchToPreview(currentTab); // Switch to preview mode
            }
        }
    });

    // Delegated event listener for dynamically added shortcut buttons
    markdownShortcuts.addEventListener('click', (e) => {
        const button = e.target.closest('.shortcut-button');
        if (!button) return;

        const markdownSyntax = button.dataset.markdown;
        let cursorOffset = parseInt(button.dataset.offset || '0');
        const isList = button.dataset.list === 'true';

        const currentTextarea = getCurrentTextarea();
        if (currentTextarea) {
            if (isList) {
                insertListItem(currentTextarea, markdownSyntax);
            } else {
                insertAtCursor(currentTextarea, markdownSyntax, cursorOffset);
            }
        }
    });

    // Top Bar Button Event Listeners
    fileBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent document click from closing it immediately
        fileDropdown.classList.toggle('hidden');
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (!fileDropdown.contains(e.target) && !fileBtn.contains(e.target)) {
            fileDropdown.classList.add('hidden');
        }
    });

    importBtn.addEventListener('click', () => {
        console.log("Import button clicked.");
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.md, .txt, .mder'; // Accept markdown, text, and .mder files
        input.style.display = 'none'; // Keep it hidden
        document.body.appendChild(input); // Temporarily append to DOM

        console.log("Created file input and appending to body.");

        input.onchange = e => {
            console.log("File input onchange event fired.");
            const file = e.target.files[0];
            if (!file) {
                console.log("No file selected or selection cancelled.");
                document.body.removeChild(input); // Clean up
                return;
            }

            console.log("File selected:", file.name, file.type, file.size);

            const reader = new FileReader();
            reader.onload = event => {
                console.log("FileReader onload event fired. Content loaded.");
                const content = event.target.result;
                const fileName = file.name.split('.').slice(0, -1).join('.') || 'インポートされたファイル';

                let importedAsMultiTab = false;
                let parsedTabs = [];

                if (file.name.toLowerCase().endsWith('.mder') || file.name.toLowerCase().endsWith('.txt')) {
                    // Always try to parse as multi-tab if it's .mder or .txt
                    parsedTabs = parseCombinedTabsFile(content);
                    if (parsedTabs.length > 0) { // If any tabs were successfully parsed
                        // Clear existing tabs' DOM elements before replacing the array
                        tabs.forEach(tab => {
                            if (tab._textarea && tab._textarea.parentNode) {
                                tab._textarea.parentNode.removeChild(tab._textarea);
                            }
                            if (tab._preview && tab._preview.parentNode) {
                                tab._preview.parentNode.removeChild(tab._preview);
                            }
                        });
                        tabs = parsedTabs;
                        currentTabId = tabs[0].id;
                        importedAsMultiTab = true;
                        showModalMessage('インポート成功', `${tabs.length}個のタブがファイルから復元されました。`, 'import-success-multi');
                    }
                }

                if (!importedAsMultiTab) {
                    // If it's not a recognized multi-tab file, or parsing failed, import as a single tab.
                    // Instead of creating a new tab, update the current active tab.
                    const currentTab = tabs.find(t => t.id === currentTabId);
                    if (currentTab) {
                        currentTab.name = fileName;
                        currentTab.content = content;
                        // Force switch to edit mode to ensure textarea is visible and updated.
                        switchToEdit(currentTab); 
                        
                        tabTitleInput.value = fileName;
                        renderTabList();
                        showModalMessage('インポート成功', `ファイル「${fileName}」が現在のタブにインポートされました。`, 'import-success-single');
                    } else {
                        // Fallback: If no current tab exists (shouldn't happen with init() logic), create a new one.
                        const newTab = createTab(fileName, content);
                        tabs.push(newTab);
                        currentTabId = newTab.id;
                        renderContent();
                        switchTab(newTab.id);
                        showModalMessage('インポート成功', `ファイル「${fileName}」が新しいタブとしてインポートされました。`, 'import-success-single');
                    }
                }
                
                // If importing multiple tabs, render and switch to the first.
                // If importing a single tab into the current one, renderContent/switchTab is not needed here
                // because _updateContentAndPreview() already handles it.
                if (importedAsMultiTab) {
                    renderContent();
                    switchTab(currentTabId);
                }
                
                document.body.removeChild(input); // Clean up
            };
            reader.onerror = (error) => {
                console.error("FileReader onerror event fired:", error);
                showModalMessage('エラー', `ファイルの読み込みに失敗しました。<br>詳細: ${error.message || '不明なエラー'}`, 'import-error-modal');
                document.body.removeChild(input); // Clean up
            };
            reader.readAsText(file);
        };
        input.click(); // Programmatically click the input
        fileDropdown.classList.add('hidden'); // Hide dropdown after selection
    });

    /**
     * Parses content from a combined tabs file into an array of tab objects.
     * @param {string} fileContent - The content of the combined file.
     * @returns {Array<object>} An array of tab objects.
     */
    function parseCombinedTabsFile(fileContent) {
        const parsedTabs = [];
        // Use a robust regex to split by the new TAB_FILE_DELIMITER, allowing for different newlines (\n, \r\n, \r)
        // and optional whitespace around the separator.
        const delimiterRegex = new RegExp(`(?:\\r?\\n|\\r)\\s*${TAB_FILE_DELIMITER.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*(?:\\r?\\n|\\r)`);
        const tabBlocks = fileContent.split(delimiterRegex);

        tabBlocks.forEach(block => {
            block = block.trim(); // Trim the entire block to remove any leading/trailing whitespace
            if (block === '') {
                return; // Skip empty blocks
            }

            let tabName = '無題';
            let tabContent = block; // Assume whole block is content initially

            // Use regex to find the tab name line at the very beginning of the block (after trimming)
            // The 'm' flag makes '^' match the start of a line, not just the start of the string.
            const nameMatch = block.match(/^# タブ名: (.+?)(?:\r?\n|\r|$)/m); 
            
            if (nameMatch) {
                tabName = nameMatch[1].trim(); // Captured group is the name
                // Remove the matched name line (including its newline) from the block to get just the content
                tabContent = block.substring(nameMatch[0].length).trim();
            }
            
            parsedTabs.push(createTab(tabName, tabContent));
        });
        return parsedTabs;
    }


    exportBtn.addEventListener('click', () => {
        const currentTab = tabs.find(t => t.id === currentTabId);
        if (!currentTab) {
            showModalMessage('エラー', 'エクスポートするタブが選択されていません。', 'export-error-modal');
            return;
        }

        const content = currentTab.content;
        // Use .md extension for single tab export
        const fileName = sanitizeFilename(currentTab.name || '無題') + '.md';
        const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' }); // Use markdown MIME type
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = fileName;
        link.click();
        URL.revokeObjectURL(link.href); // Clean up the URL object
        fileDropdown.classList.add('hidden'); // Hide dropdown after action
    });

    // Event listener for the new "Save All as Single File" button
    saveAllTabsBtn.addEventListener('click', () => {
        fileDropdown.classList.add('hidden'); // Hide dropdown

        if (tabs.length === 0) {
            showModalMessage('情報', '保存するタブがありません。', 'no-tabs-single-file');
            return;
        }

        let combinedContent = '';
        tabs.forEach((tab, index) => {
            combinedContent += `# タブ名: ${tab.name || '無題'}\n`;
            combinedContent += `${tab.content}\n\n`; // Add content with two newlines
            if (index < tabs.length - 1) {
                combinedContent += `${TAB_FILE_DELIMITER}\n\n`; // Use the new delimiter
            }
        });

        const fileName = 'Md_All.txt'; // Changed filename here
        const blob = new Blob([combinedContent], { type: 'text/plain;charset=utf-8' }); // Use plain text MIME type
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = fileName;
        link.click();
        URL.revokeObjectURL(link.href); // Clean up
        // Removed showModalMessage call here
    });

    icloudLinkBtn.addEventListener('click', () => {
        window.open(icloudUrl, '_blank'); // Open iCloud URL in a new tab/window
        fileDropdown.classList.add('hidden'); // Hide dropdown after action
    });


    // Settings Modal Event Listeners
    settingsBtn.addEventListener('click', () => {
        settingsModalOverlay.classList.add('open');
        renderSettingsShortcutsList(); // Render list when modal opens
        icloudUrlInput.value = icloudUrl; // Set current iCloud URL in input field
    });

    settingsModalCloseBtn.addEventListener('click', () => {
        settingsModalOverlay.classList.remove('open');
    });

    settingsModalOverlay.addEventListener('click', (e) => {
        if (e.target === settingsModalOverlay) {
            settingsModalOverlay.classList.remove('open');
        }
    });

    // Theme radio button listeners
    themeLightRadio.addEventListener('change', () => {
        applyTheme('light');
        saveSettings();
    });
    themeDarkRadio.addEventListener('change', () => {
        applyTheme('dark');
        saveSettings();
    });

    // Add new shortcut button listener
    addNewShortcutBtn.addEventListener('click', () => {
        const text = newShortcutText.value.trim();
        const markdown = newShortcutMarkdown.value; // Markdown can contain spaces, no trim
        const offset = parseInt(newShortcutOffset.value, 10);

        if (!text || !markdown || isNaN(offset)) {
            showModalMessage('エラー', '表示テキスト、Markdown構文、カーソルオフセットをすべて入力してください。', 'add-shortcut-error-modal');
            return;
        }

        const newId = 'custom_' + Date.now(); // Simple unique ID for custom shortcuts
        userManagedShortcuts.push({ // Added to userManagedShortcuts
            id: newId,
            text: text,
            markdown: markdown,
            offset: offset,
            title: text, // Use text as title for custom buttons
            hidden: false // New custom shortcuts are visible by default
        });

        saveSettings();
        renderShortcutButtons();
        renderSettingsShortcutsList(); // Update the list in the settings modal

        // Clear input fields
        newShortcutText.value = '';
        newShortcutMarkdown.value = '';
        newShortcutOffset.value = '0';
    });

    // Reset shortcuts button listener
    resetShortcutsBtn.addEventListener('click', () => {
        // Use a custom confirmation dialog instead of alert/confirm
        const modalId = 'reset-confirm-modal';
        let modal = document.getElementById(modalId);
        if (!modal) {
            modal = document.createElement('div');
            modal.id = modalId;
            modal.className = 'settings-modal-overlay';
            modal.innerHTML = `
                <div class="settings-modal-content">
                    <div class="settings-modal-header">
                        <h2>確認</h2>
                        <button class="settings-modal-close-btn confirm-cancel">&times;</button>
                    </div>
                    <div class="settings-modal-body">
                        <p>ショートカットの配置と表示設定を初期設定に戻します。よろしいですか？追加したカスタムショートカットもすべて削除されます。</p>
                        <div class="flex justify-end gap-4 mt-6">
                            <button class="toggle-btn confirm-cancel">キャンセル</button>
                            <button class="toggle-btn bg-red-600 hover:bg-red-700 confirm-ok">リセット</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            modal.querySelector('.confirm-ok').onclick = () => {
                userManagedShortcuts = [...defaultInitialShortcuts]; // Reset to initial defaults, all visible
                saveSettings();
                renderShortcutButtons();
                renderSettingsShortcutsList();
                showModalMessage('成功', 'ショートカットの設定が初期設定にリセットされました。', 'reset-success-modal');
                modal.classList.remove('open');
            };
            modal.querySelectorAll('.confirm-cancel').forEach(btn => {
                btn.onclick = () => modal.classList.remove('open');
            });
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.classList.remove('open');
            });
        }
        modal.classList.add('open');
    });

    // Save iCloud URL button listener
    saveIcloudUrlBtn.addEventListener('click', () => {
        const newUrl = icloudUrlInput.value.trim();
        if (newUrl) {
            // Basic URL validation
            try {
                new URL(newUrl); // Throws an error if not a valid URL
                icloudUrl = newUrl;
                saveSettings();
                showModalMessage('設定', 'iCloud URLが保存されました。', 'icloud-url-success-modal');
            } catch (e) {
                showModalMessage('エラー', '有効なiCloud URLを入力してください。', 'icloud-url-error-modal');
            }
        } else {
            showModalMessage('エラー', '有効なiCloud URLを入力してください。', 'icloud-url-error-modal');
        }
    });

    // Drag and Drop Logic for Shortcut List in Settings Modal
    currentShortcutsList.addEventListener('dragstart', (e) => {
        const draggedItem = e.target.closest('.shortcut-list-item');
        if (!draggedItem || draggedItem.draggable === false) { // Ensure only draggable items can be dragged
            e.preventDefault();
            return;
        }
        draggedShortcutId = draggedItem.dataset.shortcutId;
        e.dataTransfer.setData('text/plain', draggedShortcutId);
        setTimeout(() => {
            draggedItem.classList.add('dragging');
        }, 0); // Add class after a tiny delay to avoid affecting the ghost image
    });

    currentShortcutsList.addEventListener('dragover', (e) => {
        e.preventDefault(); // Allow drop
        const targetItem = e.target.closest('.shortcut-list-item');
        if (targetItem && !targetItem.classList.contains('dragging')) {
            // Remove previous drag-over class
            const prevDragOver = document.querySelector('.shortcut-list-item.drag-over');
            if (prevDragOver) {
                prevDragOver.classList.remove('drag-over');
            }
            // Add drag-over class to current target
            targetItem.classList.add('drag-over');
        }
    });

    currentShortcutsList.addEventListener('dragleave', (e) => {
        // Only remove if leaving the actual item that had drag-over, not its children
        if (e.target.classList.contains('drag-over')) {
            e.target.classList.remove('drag-over'); 
        }
    });

    currentShortcutsList.addEventListener('drop', (e) => {
        e.preventDefault();
        const droppedOnItem = e.target.closest('.shortcut-list-item');
        const draggedItem = document.querySelector('.shortcut-list-item.dragging');

        // Remove drag-over class from all elements
        document.querySelectorAll('.shortcut-list-item.drag-over').forEach(item => {
            item.classList.remove('drag-over');
        });

        if (!draggedItem || !droppedOnItem || draggedItem === droppedOnItem || draggedItem.draggable === false) {
            return;
        }

        const draggedId = draggedItem.dataset.shortcutId;
        const droppedOnId = droppedOnItem.dataset.shortcutId;

        const draggedIndex = userManagedShortcuts.findIndex(s => s.id === draggedId);
        const droppedOnIndex = userManagedShortcuts.findIndex(s => s.id === droppedOnId);

        if (draggedIndex === -1 || droppedOnIndex === -1) {
            console.error("Dragged or dropped shortcut not found in userManagedShortcuts.");
            return;
        }

        // Remove the dragged item from its current position
        const [movedItem] = userManagedShortcuts.splice(draggedIndex, 1);
        
        // Determine the insertion index based on mouse position relative to the target item
        const rect = droppedOnItem.getBoundingClientRect();
        const dropY = e.clientY;
        const midY = rect.top + rect.height / 2;

        let targetInsertIndex = droppedOnIndex;
        if (dropY > midY) {
            // If dropping on the bottom half, insert after the target
            targetInsertIndex++; 
        }
        
        // Insert the dragged item at the new position
        // This splice handles cases where targetInsertIndex is at the end or before the original position
        userManagedShortcuts.splice(targetInsertIndex, 0, movedItem);

        saveSettings();
        renderShortcutButtons(); // Re-render main panel
        renderSettingsShortcutsList(); // Re-render settings list
    });

    currentShortcutsList.addEventListener('dragend', (e) => {
        const draggedItem = e.target.closest('.shortcut-list-item');
        if (draggedItem) {
            draggedItem.classList.remove('dragging');
        }
        draggedShortcutId = null;
    });


    // Resize handling
    let isResizing = false;
    resizer.addEventListener('mousedown', e => {
        isResizing = true;
        document.body.style.userSelect = 'none';
        document.body.style.cursor = 'ew-resize';
    });
    document.addEventListener('mouseup', e => {
        isResizing = false;
        document.body.style.userSelect = '';
        document.body.style.cursor = 'default';
    });
    document.addEventListener('mousemove', e => {
        if (!isResizing) return;
        let newWidth = e.clientX;
        if (newWidth < 4) newWidth = 4;
        if (newWidth > 400) newWidth = 400; // Increased max width
        tabList.style.width = newWidth + 'px';
        if (newWidth <= 8) {
            tabList.classList.add('minimized');
            isTabListOpen = false;
        } else {
            tabList.style.width = '250px'; // Default width
            tabList.classList.remove('minimized');
            isTabListOpen = true;
        }
    });

    // Minimize/restore on boundary click
    resizer.addEventListener('click', () => {
        if (isResizing) return; // Exclude click detection after drag
        if (isTabListOpen) {
            tabList.style.width = '4px';
            tabList.classList.add('minimized');
            isTabListOpen = false;
        } else {
            tabList.style.width = '250px'; // Default width
            tabList.classList.remove('minimized');
            isTabListOpen = true;
        }
    });

    // Initialization
    (function init() {
        const settings = loadSettings(); // Load settings first
        applyTheme(settings.theme); // Apply theme based on loaded settings

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // service-worker.jsのパスをルート相対パスで指定
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registered with scope:', registration.scope);
                    })
                    .catch(error => {
                        console.error('Service Worker registration failed:', error);
                    });
            });
        }

        if (tabs.length === 0) {
            // If no data in local storage, create initial tab
            // Removed default content as per user request
            const tab1 = createTab('無題', ''); 
            tabs.push(tab1);
            currentTabId = tab1.id;
        }

        renderTabList();
        renderContent();
        // Always switch to the first tab, as history is removed.
        if (tabs.length > 0) {
            switchTab(tabs[0].id); // Activate initial tab
        }
        renderShortcutButtons(); // Render shortcut buttons on initial load
    })();

</script>

</body>
</html>
